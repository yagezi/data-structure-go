# leetcode算法

遍历常见的算法
遍历常见的数据结构
空间和时间的互换
预处理（例如排序）

注意判断边界

www.hackerrank.com


## 递归
递归树
只需要知道这递归树的高度 h，用高度 h 乘以递归树每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。

使用缓存来避免重复计算（递归树的剪枝）

### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

## 处理问题的思想：算法方法论
贪心法：局部最优解
分治法
回溯法
动态规划

画递归树


## 回溯
回溯算法很多时候都应用在“搜索”这类问题上
回溯算法非常适合用递归代码实现

回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。

暴力枚举

## 动态规划 Dynamic Programming
动态规划比较适合用来求解最优问题

用于处理决策过程

动态规划可用剪枝后的决策树表示
动态规划可以用状态转移表表示
动态规划可用状态转移方程表示

对于一些回溯问题，对递归树进行剪枝后，时间复杂度和动态规划处于同一量级

### 什么样的问题适合用动态规划来解决
一个模型，三个特征

一个模型：多阶段决策过程。对问题设法引入m个阶段分析，每个阶段对应n种决策，一共能找出n*m条决策序列。在n*m条决策序列中存在一个最优解序列

三个特征：最优子结构，无后效性，重复子问题
最优子结构：可以通过子问题的最优解，推导出问题的最优解
无后效性：当前时刻的状态，只由前面若干次状态及决策决定，与后面的状态及决策没有关系
重复子问题：不同的决策序列，在某个阶段会发生状态合并，达到相同的状态


动态规划具有马尔可夫性
每个决策阶段都对应着一组状态矩阵；当前时刻的状态只由上一时刻的状态及当前决策决定（一阶）；或者当前时刻的状态只由前N时刻的状态及当前决策决定。


贪心每一步只需要保留那一个最优解， 回溯每一步所有解都保留， 动态规划只去掉状态重复解，

