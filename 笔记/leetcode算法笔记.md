# leetcode算法

遍历常见的算法
遍历常见的数据结构
空间和时间的互换
预处理（例如排序）

注意判断边界

www.hackerrank.com


## 递归
递归树
只需要知道这递归树的高度 h，用高度 h 乘以递归树每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。

使用缓存来避免重复计算（递归树的剪枝）

### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

## 处理问题的思想：算法方法论
贪心法：局部最优解
分治法
回溯法
动态规划

画递归树


## 回溯
回溯算法很多时候都应用在“搜索”这类问题上
回溯算法非常适合用递归代码实现

回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。

暴力枚举

## 动态规划 Dynamic Programming
动态规划比较适合用来求解最优问题

用于处理决策过程

动态规划可用剪枝后的决策树表示
动态规划可以用状态转移表表示
动态规划可用状态转移方程表示

对于一些回溯问题，对递归树进行剪枝后，时间复杂度和动态规划处于同一量级


### 什么样的问题适合用动态规划来解决
一个模型，三个特征

一个模型：多阶段决策过程。对问题设法引入m个阶段分析，每个阶段对应n种决策，一共能找出n*m条决策序列。在n*m条决策序列中存在一个最优解序列

三个特征：最优子结构，重复子问题，无后效性
最优子结构：通过子问题的最优解，可以推导出问题的最优解
重复子问题：不同的决策序列，在某个阶段会发生状态合并，达到相同的状态
无后效性：当前时刻的状态，只由前面若干次状态及决策决定，与后面的状态及决策没有关系


动态规划具有马尔可夫性
每个决策阶段都对应着一组状态矩阵；当前时刻的状态只由上一时刻的状态及当前决策决定（一阶）；或者当前时刻的状态只由前N时刻的状态及当前决策决定。


贪心每一步只需要保留那一个最优解， 回溯每一步所有解都保留， 动态规划只去掉状态重复解，

### 如何解决动态规划问题
1. 定义状态
状态 = 子问题 = 递归函数的定义

2. 定义状态的转移
状态转移方程 = 递推公式g(x) s.t. f(n) = g(f(n-1), f(n-2), ..., f(0))

3. 定义边界条件


### 区间dp
根据区间长度定义状态为dp[i][l]
其中i为区间起始位置，l为区间长度

根据区间尾索引定义状态为dp[i][j]
dp in range [i, j)

此时遍历i需要从右到左，从大到小，例如：
for (int i = len - 2; i >= 0; i--) {
    for (int j = i + 1; j < len; j++) {




## 查找
二分查找



## tips
求整数的逆序排列
    for y > 0 {
        reverse = reverse*10 + y %10
        y /= 10
    }


## go std container
sort & search
unstable sort: quick sort
stable sort: merge sort
sorted search: binary search

heap
堆、优先队列

list
链表、栈、队列

## 最短路径
A*搜索

欧式距离
曼哈顿距离
对角线距离（切比雪夫距离）


### 选择合适的最短路径算法
有向或无向的无权图 				BFS，A-star(A*)
有向无环图，正负权值(DAG)  		topo sort， Bellman Ford	
一般有向图，正权值 				Dijkstra
有向图，正负权值				Bellman Ford	

单源单目的地，有权图或无权       A-star(A*)
单源多目的地，无权              BFS
单源多目的地，正权值            Dijkstra
单源多目的地，正负权值          Bellman Ford
多源多目的地                   Floyd, Johnson
（所有顶点到所有顶点）

### Dijkstra
使用path数组记录最短路径。path[i] = 顶点src到顶点i的最短路径上，i的前驱顶点。
path[src] = src

dijkstra不能处理有向负权值图。对于有向负权值图，应该用Bellman Ford处理

### A-star
TODO

## 单调栈

求解问题涉及输入数据的凹凸性时（如接雨水问题），需考虑使用单调栈

## leetcode 刷题笔记
https://books.halfrost.com/leetcode/


## 博弈论问题

- 特征
two players
take turns
both play optimally

- 如何解决博弈论问题
记忆化搜索
动态规划


