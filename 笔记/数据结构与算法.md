# 数据结构与算法笔记

## 排序

### 排序的稳定性

### 内排序与外排序
是否所有记录都放在内存中

### 性能
时间复杂度、空间复杂度、算法复杂性

### 冒泡
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

### 选择
O(n^2)

### 插入排序
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

近似有序情况下，插入排序速度最快
底层为链表情况下，插入排序速度最快

### 堆排序
升序使用大顶堆，降序使用小顶堆
思路：
1、将长度为n的数组调整为大顶堆，此时堆顶为最大值
2、将堆顶和堆的末尾元素交换
3、将前n-1个元素调整为大顶堆
4、重复2、3，直到n=1

如何生成大顶堆：分治、递归，动态规划
假设：对数组r[s:n], 其中除r[s]外，r[s+1:n]已经是一个大顶堆
问题：如何将r[s]按照大小插入到堆中

1、保存r[s]的值为temp
2、找出r[s], r[2*s], r[2*s+1]的最大值，赋给r[s]
3、找出temp插入的位置。如果temp为三者的最大值，则break

堆排序不是稳定排序

时间复杂度 O(nlogn)
最好（有序） O(nlogn)
最坏（倒叙） O(nlogn)

### 归并排序
思路：
假设:对数组r[s:n], 有r[s:m]和r[m+1:n]分别是有序的
问题：如何使r[s:n]有序
滑动指针

最好，最坏，平均  O(nlogn)

外排序，能够并发
并发时两路归并最快

### 快速排序
冒泡排序的升级  
不稳定排序

partition的复杂度为O(n)
递归次数为树的深度
最好，pivot选择合理，构成平衡树，递归次数为logn，总复杂度为O(nlogn)
最坏，pivot选择很不合理，每次都是最小（or最大）值，构成偏树，递归次数为n，复杂度为O(n^2)
平均O(n^2)

空间复杂度为递归次数（即树的深度）相关
O(logn) 或 O(n)

3路快排


### 计数排序


## 链表

### append节点

### 删除节点

### 反转链表
递归实现
循环实现  三指针法

## 栈

### 后缀逆波兰表达式 post-RPN

### 中缀逆波兰表达式 RPN
