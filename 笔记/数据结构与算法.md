# 数据结构与算法笔记

## 排序

### 排序的稳定性

### 内排序与外排序
是否所有记录都放在内存中

### 性能
时间复杂度、空间复杂度、算法复杂性

### 冒泡
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

### 选择
O(n^2)

### 插入排序
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

近似有序情况下，插入排序速度最快
底层为链表情况下，插入排序速度最快
直接插入排序是简单排序中性能最好的

### 堆排序
升序使用大顶堆，降序使用小顶堆
思路：
1、将长度为n的数组调整为大顶堆，此时堆顶为最大值
2、将堆顶和堆的末尾元素交换
3、将前n-1个元素调整为大顶堆
4、重复2、3，直到n=1

如何生成大顶堆：分治、递归，动态规划
假设：对数组r[s:n], 其中除r[s]外，r[s+1:n]已经是一个大顶堆
问题：如何将r[s]按照大小插入到堆中

1、保存r[s]的值为temp
2、找出r[s], r[2*s], r[2*s+1]的最大值，赋给r[s]
3、找出temp插入的位置。如果temp为三者的最大值，则break

堆排序不是稳定排序

时间复杂度 O(nlogn)
最好（有序） O(nlogn)
最坏（倒叙） O(nlogn)

### 归并排序
思路：
假设:对数组r[s:n], 有r[s:m]和r[m+1:n]分别是有序的
问题：如何使r[s:n]有序
滑动指针

最好，最坏，平均  O(nlogn)

外排序，能够并发

### 快速排序
冒泡排序的升级  
不稳定排序

partition的复杂度为O(n)
递归次数为树的深度
最好，pivot选择合理，构成平衡树，递归次数为logn，总复杂度为O(nlogn)
最坏，pivot选择很不合理，每次都是最小（or最大）值，构成偏树，递归次数为n，复杂度为O(n^2)
平均O(n^2)

空间复杂度为递归次数（即树的深度）相关
O(logn) 或 O(n)

3路快排

小数组时使用直接插入排序替代快排

### 计数排序
当元素取值范围有限时，可考虑计数排序/基数排序/桶排序。

设待排序元素e < k

计数排序：时间复杂度O(n + k)，空间复杂度O(k)


### 基数排序
当 k=n^2时，时间复杂度退化为O(n^2)。
此时使用基数排序，时间复杂度为O(d(n+b)) 其中n为列表长度（元素个数），d为最大位数，d = log_r(k)；b为基数，当元素为十进制数字时，基数为10；当为英文字符串时，基数为128

设待排序元素e < k

因此，一般情况下，对于 < k=n^c 的待排数据，基数排序的复杂度为O((n+b)log_b(k))

求整数的各个位: x / exp % base 

### 桶排序
当对范围有限且分布均匀的数据进行排序，且数据不便于计数（例如浮点数）时， 可使用桶排序。
时间复杂度和下列过程的复杂度有关：
- 对桶中插入数据
- 桶中使用的排序算法的复杂度有关
 
通常为O(n)

对整数部分不为0的浮点数进行桶排序，算法如下:

1. 找到数据的最大值和最小值
2. 计算每个桶的range
          range = ceil((max - min) / n)
  其中n是桶的数量, 向上取整
3. 创建n个桶
4. 将数组中的元素分散到各个桶中
  BucketIndex = ( arr[i] - min ) / range
  向下取整
5. 分别对每个桶中的元素进行排序
6. 将各个桶中已排序的数组合并到原始数组


## 链表

### append节点

### 删除节点

### 反转链表
递归实现
循环实现  三指针法

## 跳表 skiplist

## 栈和队列

### 后缀逆波兰表达式 post-RPN

### 中缀逆波兰表达式 RPN


### 两个栈实现队列
s1是入栈的，s2是出栈的。

入队列：如果s1满且s2空，将s1所有元素弹出全部压入s2；否则直接压入s1；
出队列：如果s2不为空，把s2中的栈顶元素直接弹出；否则，把s1的所有元素全部弹出压入s2中，再弹出s2的栈顶元素


### 两个队列实现栈
q1是专职进出栈的，q2只是个中转站。元素集中存放在一个栈中，但不是指定(q1 或 q2)。

    定义两个指针：master:指向专门进栈的队列； minion：指向临时作为中转站的另一个栈

入栈：直接入master所指队列即可
出栈：把master的除最后一个元素外全部转移到队列minion中,然后把最后一个元素出队列，并交换master和minion指针的值

## 串

### 字典序

### 子串的匹配

#### BF算法 
Brute-Force

#### KMP算法
- next数组
  next[i]表示 P[i-1] 这一个子串，使得前k个字符（前缀）等于后k个字符（后缀）的最大的k，其中前缀和后缀是可以重叠的。
  对于长度为n的串，i < n+1，因为P(n+1)就是串本身，自己肯定与自己相等，就没有意义了

  T[next(i)] = 子串P(i)的最长相等前缀的后一个元素

- 时间复杂度 目标串S长度为n，模式串长度为m，O(n + m)

#### BM算法
- 坏字符（Bad Character）
- 好后缀（Good Suffix）

在BM算法匹配的过程中，取 坏字节和好后缀 中的较大值作为跳跃的距离。

grep工具默认算法

O(n/m) - O(n*m)

#### Sunday算法

- 坏字符
在BM算法基础上改进, 关注的是主串中参与匹配的最末字符的下一位，而不是正在匹配的字符

如果坏字符没有在模式串中出现，移动位数 = 模式串长度 + 1；

当坏字符在模式串中出现时：
移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始)
or 移动位数 = 模式串中该字符最右出现的位置到尾部的距离 + 1

O(n/m) - O(n*m)



## 二叉树 binary tree

## 树的相关概念
- 根节点、分支节点、叶子节点
- 孩子节点、父节点、兄弟节点

- 节点的度 Degree
- 树的深度 depth
- 树的节点数量 n

森林：m棵互不相交的树的集合

### 二叉树概念
- 不存在度 > 2的节点
- 左右子树是有顺序的。并且，即使只有一棵子树，也要区分是左子树还是右子树

- 斜树：所有节点只有左子树的称为左斜树，所有节点只有右子树成为右斜树。
- 满二叉树
深度相同时，满二叉树的节点数最多

- 完全二叉树

### 二叉树性质
1. 深度为d的满二叉树，叶子节点数量为2^(d-1), 即二叉树第d层最多有2^(d-1)个节点
2. 深度为d的满二叉树有2^d - 1 个节点
3. 具有n个节点的完全二叉树的深度为 log2(n) + 1
4. 一棵二叉树的叶子节点数量为n0，度为2节点的数量为n2，则n0 = n2 + 1

5. 已知前序序列、中序序列，可唯一确定一棵二叉树
6. 已知中序序列、后序序列，可唯一确定一棵二叉树
7. 已知前序序列、后序序列，**不能**唯一确定一棵二叉树

### 二叉树存储结构
- 数组：通常仅适用于完全二叉树
- 链表

### 二叉树的遍历 traversion
1. 前序 根 -> 左 -> 右
2. 中序 左 -> 根 -> 右
3. 后续 左 -> 右 -> 根
4. 层序

### 二叉查找树 binary search tree

### AVL树
属于平衡二叉查找树

平衡二叉查找树的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

作为平衡二叉树，Treap（树堆）、Splay Tree（伸展树），绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，AVL 树的效率会很低。

### 红黑树 RBTree
属于广义的平衡二叉查找树

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

#### 性质
- 每个节点要么是黑色，要么是红色。
- 根节点是黑色。
- 每个叶子节点（NIL）是黑色。
- 每个红色结点的两个子结点一定都是黑色。
- 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。



### 递归树
将递归过程用树展示出来。用于估算递归算法的时间复杂度

## 多路查找树

### 2-3 树

### B+树
是一种多路查找树。主要用于速度不同的存储介质/io 数据交互，如内外存、内存/网络io等

B+树在B树的改进在于范围查找。如果是随机访问，方式与B树相同；如果是范围查找，沿着指向下一个叶子节点的链表进行遍历。

与B树相比，减少了对索引节点的访问次数。由于每访问一个节点，就涉及一次读取外存数据，因此也减少了读取外存的次数。

## Trie树 字典树
 多叉树

 精确匹配通常使用散列表、红黑树

 前缀匹配、敏感词过滤、搜索框联想、自动补全通常使用字典树

 带mask的trie：用于任意片段的模糊查找，如输入"fb"找到"facebook"。
 通过掩码和位运算进行模糊查找：若 mask(partial) & mask(serial) == mask(partial), 则partial in serial



## 散列表
也称为哈希表

### 散列表的缺点
查找不光是查找某一个值，还会查找一个特定的范围，这在散列表里面就不一定适用了。类似B+树之类的，只在叶子节点保存数据，并且将其用链表连起来。散列表在扩缩容的时候，性能不大稳定，同时由于散列冲突的存在，虽然散列表的时间复杂度是常数级别的，但实际应用中，由于其不稳定，性能也不一定会比平衡二叉搜索树好。

### 散列函数
散列函数是单调非负的函数：

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。但是这一点几乎无法实现

尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。
散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能


### 装载因子
装载因子=填入表中的元素个数/散列表的长度
装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 散列冲突
开放地址法和链表法

散列表碰撞攻击

大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。

但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。

jdk1.8 map 元素个数大于8个，链表转为红黑树；元素个数小于6个，红黑树转为链表

### 散列表扩容


## 图

### 概念
顶点
边
顶点的度
边的方向
有向图的度：出度，入度
边的权重

### 图的存储结构
1. 邻接矩阵

邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。

方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。

浪费存储空间，特别是对于稀疏图

2. 邻接表

适用于稀疏图

每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点

可将链表优化为跳表、红黑树、动态数组、散列表

对于有向图，可扩展为逆邻接表

### 最小生成树 
minimum spanning tree
设边数为e，顶点数为v
对于图来说，不等式 e < v^2 恒成立

####  kruskal
思路：
1. 对边按权重进行升序排序
2. 由小到大依次取每条边，若不构成环，则添加到集合 A 中。可使用并查集判断边是否形成环路
3. 重复执行步骤 2，直到添加 |V|-1 条边

时间复杂度
对边排序O(eloge)，并查算法O(elogv)，总时间复杂度为O(eloge + elogv)
由于不等式恒成立，O(loge) = O(logv)，则总时间复杂度简化为 O(eloge) 或者 O(elogv)

空间复杂度 O(v)
并查集、对边排序需要开辟数组

边数少时效率高，适用于稀疏图
####  prim
思路：
1. 按照距离子图的远近，对顶点集合进行排序
2. 选择最近的顶点加入到子图中，并更新相邻顶点对子图的距离
3. 重复执行步骤 2，直到顶点集合为空


对于邻接矩阵，时间复杂度O(v^2)
对于邻接表，时间复杂度为O(elogv)

边数多时性能相对更好，适用于稠密图

## 并查集
Disjoint Set

用于处理图的连通性问题 or 不相交集合的合并问题

模型为子节点指向父节点的树。实现为数组。

路径压缩

常用方法：
root Find(x)
root Union(x, y)
