# 数据结构与算法笔记

## 排序

### 排序的稳定性

### 内排序与外排序
是否所有记录都放在内存中

### 性能
时间复杂度、空间复杂度、算法复杂性

### 冒泡
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

### 选择
O(n^2)

### 插入排序
时间复杂度 O(n^2)
最好（有序） O(n)
最坏（倒叙） O(n^2)

近似有序情况下，插入排序速度最快
底层为链表情况下，插入排序速度最快

### 堆排序
升序使用大顶堆，降序使用小顶堆
思路：
1、将长度为n的数组调整为大顶堆，此时堆顶为最大值
2、将堆顶和堆的末尾元素交换
3、将前n-1个元素调整为大顶堆
4、重复2、3，直到n=1

如何生成大顶堆：分治、递归，动态规划
假设：对数组r[s:n], 其中除r[s]外，r[s+1:n]已经是一个大顶堆
问题：如何将r[s]按照大小插入到堆中

1、保存r[s]的值为temp
2、找出r[s], r[2*s], r[2*s+1]的最大值，赋给r[s]
3、找出temp插入的位置。如果temp为三者的最大值，则break

堆排序不是稳定排序

时间复杂度 O(nlogn)
最好（有序） O(nlogn)
最坏（倒叙） O(nlogn)

### 归并排序
思路：
假设:对数组r[s:n], 有r[s:m]和r[m+1:n]分别是有序的
问题：如何使r[s:n]有序
滑动指针

最好，最坏，平均  O(nlogn)

外排序，能够并发
并发时两路归并最快

### 快速排序
冒泡排序的升级  
不稳定排序

partition的复杂度为O(n)
递归次数为树的深度
最好，pivot选择合理，构成平衡树，递归次数为logn，总复杂度为O(nlogn)
最坏，pivot选择很不合理，每次都是最小（or最大）值，构成偏树，递归次数为n，复杂度为O(n^2)
平均O(n^2)

空间复杂度为递归次数（即树的深度）相关
O(logn) 或 O(n)

3路快排


### 计数排序


## 链表

### append节点

### 删除节点

### 反转链表
递归实现
循环实现  三指针法

## 跳表 skiplist

## 栈和队列

### 后缀逆波兰表达式 post-RPN

### 中缀逆波兰表达式 RPN


### 两个栈实现队列
s1是入栈的，s2是出栈的。

入队列：如果s1满且s2空，将s1所有元素弹出全部压入s2；否则直接压入s1；
出队列：如果s2不为空，把s2中的栈顶元素直接弹出；否则，把s1的所有元素全部弹出压入s2中，再弹出s2的栈顶元素


### 两个队列实现栈
q1是专职进出栈的，q2只是个中转站。元素集中存放在一个栈中，但不是指定(q1 或 q2)。

    定义两个指针：master:指向专门进栈的队列； minion：指向临时作为中转站的另一个栈

入栈：直接入master所指队列即可
出栈：把master的除最后一个元素外全部转移到队列minion中,然后把最后一个元素出队列，并交换master和minion指针的值

## 串

### 字典序

### 子串的匹配

#### BF算法 
Brute-Force

#### KMP算法
- next数组
  next[i]表示 P[i-1] 这一个子串，使得前k个字符（前缀）等于后k个字符（后缀）的最大的k，其中前缀和后缀是可以重叠的。
  对于长度为n的串，i < n+1，因为P(n+1)就是串本身，自己肯定与自己相等，就没有意义了

  T[next(i)] = 子串P(i)的最长相等前缀的后一个元素

- 时间复杂度 目标串S长度为n，模式串长度为m，O(n + m)

#### BM算法
- 坏字符（Bad Character）
- 好后缀（Good Suffix）

在BM算法匹配的过程中，取 坏字节和好后缀 中的较大值作为跳跃的距离。

grep工具默认算法

O(n/m) - O(n*m)

#### Sunday算法

- 坏字符
在BM算法基础上改进, 关注的是主串中参与匹配的最末字符的下一位，而不是正在匹配的字符

如果坏字符没有在模式串中出现，移动位数 = 模式串长度 + 1；

当坏字符在模式串中出现时：
移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始)
or 移动位数 = 模式串中该字符最右出现的位置到尾部的距离 + 1

O(n/m) - O(n*m)



## 二叉树 binary tree

## 树的相关概念
- 根节点、分支节点、叶子节点
- 孩子节点、父节点、兄弟节点

- 节点的度 Degree
- 树的深度 depth
- 树的节点数量 n

森林：m棵互不相交的树的集合

### 二叉树概念
- 不存在度 > 2的节点
- 左右子树是有顺序的。并且，即使只有一棵子树，也要区分是左子树还是右子树

- 斜树：所有节点只有左子树的称为左斜树，所有节点只有右子树成为右斜树。
- 满二叉树
深度相同时，满二叉树的节点数最多

- 完全二叉树

### 二叉树性质
1. 深度为d的满二叉树，叶子节点数量为2^(d-1), 即二叉树第d层最多有2^(d-1)个节点
2. 深度为d的满二叉树有2^d - 1 个节点
3. 具有n个节点的完全二叉树的深度为 log2(n) + 1
4. 一棵二叉树的叶子节点数量为n0，度为2节点的数量为n2，则n0 = n2 + 1

5. 已知前序序列、中序序列，可唯一确定一棵二叉树
6. 已知中序序列、后序序列，可唯一确定一棵二叉树
7. 已知前序序列、后序序列，**不能**唯一确定一棵二叉树

### 二叉树存储结构
- 数组：通常仅适用于完全二叉树
- 链表

### 二叉树的遍历 traversion
1. 前序 根 -> 左 -> 右
2. 中序 左 -> 根 -> 右
3. 后续 左 -> 右 -> 根
4. 层序

### 二叉查找树 binary search tree

### AVL树
属于平衡二叉查找树

平衡二叉查找树的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

作为平衡二叉树，Treap（树堆）、Splay Tree（伸展树），绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，AVL 树的效率会很低。

### 红黑树 RBTree
属于广义的平衡二叉查找树

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

#### 性质
- 每个节点要么是黑色，要么是红色。
- 根节点是黑色。
- 每个叶子节点（NIL）是黑色。
- 每个红色结点的两个子结点一定都是黑色。
- 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。



### 递归树
将递归过程用树展示出来。用于估算递归算法的时间复杂度

## 多路查找树

### 2-3 树

### B+树
是一种多路查找树。主要用于速度不同的存储介质/io 数据交互，如内外存、内存/网络io等

B+树在B树的改进在于范围查找。如果是随机访问，方式与B树相同；如果是范围查找，沿着指向下一个叶子节点的链表进行遍历。

与B树相比，减少了对索引节点的访问次数。由于每访问一个节点，就涉及一次读取外存数据，因此也减少了读取外存的次数。


## 散列表
也称为哈希表

### 散列表的缺点
查找不光是查找某一个值，还会查找一个特定的范围，这在散列表里面就不一定适用了。类似B+树之类的，只在叶子节点保存数据，并且将其用链表连起来。散列表在扩缩容的时候，性能不大稳定，同时由于散列冲突的存在，虽然散列表的时间复杂度是常数级别的，但实际应用中，由于其不稳定，性能也不一定会比平衡二叉搜索树好。
